#config.py
TICK_RATE = 0.1 #Sekunden pro Tick
UNIT_MOVE_SPEED = 2.0 #Tiles pro Sekunde
TOWER_RANGE = 3.5 #Tiles
TOWER_DAMAGE = 25
TOWER_ATTACK_SPEED = 1.0 #Angriffe pro Sekunde
#main.py
import time
from config import *
from entities import tower, unit
from systems.spawn_system import SpawnSystem
from systems.unit_system import UnitSystem
from systems.cleanup_system import CleanupSystem
from systems.tower_system import TowerSystem
import map

class Game:
    #Zentrale Spielsimulation
    def __init__(self):
        self.lane = map.Lane([
            (0, 5),
            (10, 5),
            (15, 8),
            (20, 8)
        ])
        
        self.units = []
        self.towers = []
        
        #Beispiel-Tower
        self.towers.append(tower.Tower(8, 5))
        self.towers.append(tower.Tower(14, 5))
        
        self.player_hp = 20
        
        self.spawn_system = SpawnSystem(self.units, self.lane)
        self.unit_system = UnitSystem(self.units)
        self.cleanup_system = CleanupSystem(self.units, self)
        self.tower_system = TowerSystem(self.towers, self.units)

    def update(self, dt):
        #Units spwanen
        self.spawn_system.update(dt)
        
        #Units und Türme updaten
        self.unit_system.update(dt)
        self.tower_system.update(dt)
            
        #Leaks and Deaths aufräumen
        self.cleanup_system.update()
    
    def debug_print(self):
        print(f"Units: {len(self.units)} | Player HP: {self.player_hp}")
        for i, u in enumerate(self.units):
            print(
                f" Unit {i}: "
                f"pos=({u.x:.1f}, {u.y:.1f}) "
                f"hp={u.hp} "
                f"path_index={u.path_index}"
            )
    
    #def draw():
        #draw map, units and towers on the screen
            
### MAIN LOOP ###
if __name__ == "__main__":
    game = Game()

    print("Wintermaul Lane Prototyp gestartet\n")
    
    while game.player_hp > 0:
        game.update(TICK_RATE)
        game.debug_print()
        print("-" * 40)
        time.sleep(TICK_RATE)
#map.py
class Tile:
    def __init__(self, walkable: bool, buildable: bool):
        self.walkable = walkable
        self.buildable = buildable
        
class GameMap:
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.tiles = [
            [Tile(True, True) for x in range(width)]
            for y in range(height)
        ]
        
class Lane:
    # Feste Abfolge von Wegpukten
    def __init__(self, points):
        self.points = points #Liste von (x, y)
#entities/tower.py
import math
from entities import unit
from config import *

class Tower:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        
        self.range = TOWER_RANGE
        self.damage = TOWER_DAMAGE
        self.attack_speed = TOWER_ATTACK_SPEED
        self.cooldown = 0.0
        
    def update(self, dt, units):
        self.cooldown -= dt
        if self.cooldown > 0:
            return
        
        target = self.find_target(units)
        if target:
            target.take_damage(self.damage)
            self.cooldown = 1 / self.attack_speed
                
    def distance(self, unit: unit.Unit):
        return math.hypot(self.x - unit.x, self.y - unit.y)
    
    def find_target(self, units):
        #Ziel = Unit mit größtem Fortschritt in Reichweite
        
        candidates = [
            u for u in units
            if u.alive and self.distance(u) <= self.range
        ]
        
        if not candidates:
            return None
        
        return max(candidates, key=lambda u: u.progress())
#entities/unit.py
import math
from config import *
import map

class Unit:
    def __init__(self, lane: map.Lane):
        self.lane = lane
        self.path_index = 0
        
        self.x, self.y = lane.points[0]
        
        self.hp = 100
        self.max_hp = 100
        
        self.move_speed = UNIT_MOVE_SPEED
        
        self.alive = True
    
    def current_target(self):
        #Aktueller Wegpunkt
        if self.path_index >= len(self.lane.points):
            return None
        return self.lane.points[self.path_index]
    
    def progress(self):
        #Fortschritt entlang der Lane, wird für Targeting genutzt
        target = self.current_target()
        if target is None:
            return self.path_index
        tx, ty = target
        dist = math.hypot(tx - self.x, ty - self.y) #je näher am Zielpunkt, desto größer der Fortschritt
        return self.path_index + (1.0 / (1.0 + dist))

    def update(self, dt):
        #Bewegung entlang der Lane
        if not self.alive:
            return
        
        target = self.current_target()
        if target is None:
            return
        
        tx, ty = target
        dx = tx - self.x
        dy = ty - self.y
        dist = math.hypot(dx, dy)
        
        #Wegpunkt erreicht
        if dist < 0.05:
            self.path_index += 1
            return
        
        vx = dx / dist
        vy = dy / dist
        
        self.x += vx * self.move_speed * dt
        self.y += vy * self.move_speed * dt
        
        
    def take_damage(self, dmg):
        self.hp -= dmg
        if self.hp <= 0:
            self.alive = False
#systems/cleanup_system.py
class CleanupSystem:
    def __init__(self, units, game):
        self.units = units
        self.game = game
        
    def update(self):
        for unit in list(self.units):
            if not unit.alive:
                self.units.remove(unit)
            elif unit.path_index >= len(unit.lane.points):
                self.game.player_hp -= 1
                self.units.remove(unit)
#systems/economy_system.py
class Player:
    def __init__(self):
        self.gold = 100
        self.income = 5
        
    def add_income(self):
        self.gold += self.income
#systems/spawn_system.py
from entities.unit import Unit

class SpawnSystem:
    def __init__(self, units, lane):
        self.units = units
        self. lane = lane
        self. timer = 0.0
        
    def update(self, dt):
        self.timer += dt
        if self.timer >= 2.0:
            self.units.append(Unit(self.lane))
            self.timer = 0.0
#systems/tower_system.py
class TowerSystem:
    def __init__(self, towers, units):
        self.towers = towers
        self. units = units
        
    def update(self, dt):
        for tower in self.towers:
            tower.update(dt, self.units)
#systems/unit_system.py
class UnitSystem:
    def __init__(self, units):
        self.units = units
        
    def update(self, dt):
        for unit in self.units:
            unit.update(dt)