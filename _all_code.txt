#config.py
TICK_RATE = 0.1 #Sekunden pro Tick
UNIT_MOVE_SPEED = 2.0 #Tiles pro Sekunde
TOWER_RANGE = 3.5 #Tiles
TOWER_DAMAGE = 25
TOWER_ATTACK_SPEED = 1.0 #Angriffe pro Sekunde
#main.py
import time
import pygame
from config import TICK_RATE
from game_state import GameState
from renderer_pygame import PygameRenderer

if __name__ == "__main__":
    state = GameState()
    renderer = PygameRenderer()

    clock = pygame.time.Clock()
    running = True

    while running and state.player_hp > 0:
        dt = clock.tick(60) / 1000.0
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
        
        state.update(dt)
        renderer.draw(state)
    
    pygame.quit()

'''# # # # # # # # # # # # # # # # 
# Headless Test #
print("WintermaulWars Prototyp gestartet\n")

while state.player_hp > 0:
    state.update(TICK_RATE)

    print(f"Units: {len(state.units)} | Player HP: {state.player_hp}")
    for i, u in enumerate(state.units):
        print(
            f" Unit {i}: "
            f"pos=({u.x:.1f}, {u.y:.1f}) "
            f"hp={u.hp} "
            f"path_index={u.path_index}"
        )

    print("-" * 40)
    time.sleep(TICK_RATE)
# # # # # # # # # # # # # # # # # # '''
#game_state
from systems.spawn_system import SpawnSystem
from systems.unit_system import UnitSystem
from systems.cleanup_system import CleanupSystem
from systems.tower_system import TowerSystem
from entities import tower
import game_map

class GameState:
    def __init__(self):
        self.player_hp = 20
        self.units = []
        self.towers = []

        self.lane = game_map.Lane([
            (24, 41),
            (8, 41),
            (8, 65),
            (24, 65),
            (24, 80)
        ])

        self.towers.append(tower.Tower(21, 69))
        self.towers.append(tower.Tower(22, 69))
        self.towers.append(tower.Tower(23, 69))
        self.towers.append(tower.Tower(24, 69))
        self.towers.append(tower.Tower(25, 69))
        self.towers.append(tower.Tower(26, 69))
        self.towers.append(tower.Tower(27, 69))
        
        self.towers.append(tower.Tower(28, 71))
        self.towers.append(tower.Tower(22, 71))
        self.towers.append(tower.Tower(23, 71))
        self.towers.append(tower.Tower(24, 71))
        self.towers.append(tower.Tower(25, 71))
        self.towers.append(tower.Tower(26, 71))
        self.towers.append(tower.Tower(27, 71))
        
        self.towers.append(tower.Tower(21, 73))
        self.towers.append(tower.Tower(22, 73))
        self.towers.append(tower.Tower(23, 73))
        self.towers.append(tower.Tower(24, 73))
        self.towers.append(tower.Tower(25, 73))
        self.towers.append(tower.Tower(26, 73))
        self.towers.append(tower.Tower(27, 73))
        
        self.towers.append(tower.Tower(28, 75))
        self.towers.append(tower.Tower(22, 75))
        self.towers.append(tower.Tower(23, 75))
        self.towers.append(tower.Tower(24, 75))
        self.towers.append(tower.Tower(25, 75))
        self.towers.append(tower.Tower(26, 75))
        self.towers.append(tower.Tower(27, 75))


        self.spawn_system = SpawnSystem(self.units, self.lane)
        self.unit_system = UnitSystem(self.units)
        self.cleanup_system = CleanupSystem(
            self.units,
            on_unit_leak=self.on_unit_leak
        )
        self.tower_system = TowerSystem(self.towers, self.units)

    def on_unit_leak(self):
        self.player_hp -= 1

    def update(self, dt):
        self.spawn_system.update(dt)
        self.unit_system.update(dt)
        self.tower_system.update(dt)
        self.cleanup_system.update()

#game_map.py
class Tile:
    def __init__(self, walkable: bool, buildable: bool):
        self.walkable = walkable
        self.buildable = buildable
        
class GameMap:
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.tiles = [
            [Tile(True, True) for x in range(width)]
            for y in range(height)
        ]
        
class Lane:
    # Feste Abfolge von Wegpukten
    def __init__(self, points):
        self.points = points #Liste von (x, y)
#renderer_pygame
import pygame
import game_map

class PygameRenderer:
    def __init__(self, tile_size=12):
        pygame.init()
        self.tile_size = tile_size
        self.screen = pygame.display.set_mode((576, 960))
        pygame.display.set_caption("Wintermaul TD")

    def draw(self, state):
        self.screen.fill((30, 30, 30))

        # Units
        for u in state.units:
            x = int(u.x * self.tile_size)
            y = int(u.y * self.tile_size)
            pygame.draw.circle(self.screen, (200, 50, 50), (x, y), 6)

        # Towers
        for t in state.towers:
            x = int(t.x * self.tile_size)
            y = int(t.y * self.tile_size)
            pygame.draw.rect(
                self.screen,
                (50, 200, 50),
                pygame.Rect(x - 5, y - 5, 10, 10)
            )
        
        # Lane Points (Spawn / Path)
        for px, py in state.lane.points:
            x = int(px * self.tile_size)
            y = int(py * self.tile_size)
            pygame.draw.circle(self.screen, (200, 200, 0), (x, y), 3)
        
        ## Lane Points verbinden
        #points_px = [
        #    (int(px * self.tile_size), int(py * self.tile_size))
        #    for px, py in state.lane.points
        #]

        #if len(points_px) > 1:
        #    pygame.draw.lines(
        #        self.screen,
        #        (80, 80, 220),
        #        False,
        #        points_px,
        #        2
        #    )
        
        pygame.display.flip()

#entities/tower.py
import math
from entities import unit
from config import *

class Tower:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        
        self.range = TOWER_RANGE
        self.damage = TOWER_DAMAGE
        self.attack_speed = TOWER_ATTACK_SPEED
        self.cooldown = 0.0
        
    def update(self, dt, units):
        self.cooldown -= dt
        if self.cooldown > 0:
            return
        
        target = self.find_target(units)
        if target:
            target.take_damage(self.damage)
            self.cooldown = 1 / self.attack_speed
                
    def distance(self, unit: unit.Unit):
        return math.hypot(self.x - unit.x, self.y - unit.y)
    
    def find_target(self, units):
        best_target = None
        best_progress = -1.0

        for u in units:
            if not u.alive:
                continue

            if self.distance(u) > self.range:
                continue

            p = u.progress()
            if p > best_progress:
                best_progress = p
                best_target = u

        return best_target
#entities/unit.py
import math
from config import *
import game_map

class Unit:
    def __init__(self, lane: game_map.Lane):
        self.lane = lane
        self.path_index = 0
        
        self.x, self.y = lane.points[0]
        
        self.hp = 100
        self.max_hp = 100
        
        self.move_speed = UNIT_MOVE_SPEED
        
        self.alive = True
        self._progress = 0.0
    
    def current_target(self):
        #Aktueller Wegpunkt
        if self.path_index >= len(self.lane.points):
            return None
        return self.lane.points[self.path_index]
    
    def progress(self):
        return self._progress

    def update(self, dt):
        #Bewegung entlang der Lane
        if not self.alive:
            return
        
        target = self.current_target()
        if target is None:
            return
        
        tx, ty = target
        dx = tx - self.x
        dy = ty - self.y
        dist = math.hypot(dx, dy)
        
        #Wegpunkt erreicht
        if dist < 0.05:
            self.path_index += 1
            self._progress = self.path_index
            return
        
        vx = dx / dist
        vy = dy / dist
        
        self.x += vx * self.move_speed * dt
        self.y += vy * self.move_speed * dt
        
        
    def take_damage(self, dmg):
        self.hp -= dmg
        if self.hp <= 0:
            self.alive = False
#systems/cleanup_system.py
class CleanupSystem:
    def __init__(self, units, on_unit_leak):
        self.units = units
        self.on_unit_leak = on_unit_leak

    def update(self):
        alive_units = []

        for unit in self.units:
            if not unit.alive:
                continue

            if unit.path_index >= len(unit.lane.points):
                self.on_unit_leak()
                continue

            alive_units.append(unit)

        self.units[:] = alive_units
#systems/economy_system.py
class Player:
    def __init__(self):
        self.gold = 100
        self.income = 5
        
    def add_income(self):
        self.gold += self.income
#systems/spawn_system.py
from entities.unit import Unit

class SpawnSystem:
    def __init__(self, units, lane):
        self.units = units
        self. lane = lane
        self. timer = 0.0
        
    def update(self, dt):
        self.timer += dt
        if self.timer >= 1.25:
            self.units.append(Unit(self.lane))
            self.timer = 0.0
#systems/tower_system.py
class TowerSystem:
    def __init__(self, towers, units):
        self.towers = towers
        self. units = units
        
    def update(self, dt):
        for tower in self.towers:
            tower.update(dt, self.units)
#systems/unit_system.py
class UnitSystem:
    def __init__(self, units):
        self.units = units
        
    def update(self, dt):
        for unit in self.units:
            unit.update(dt)